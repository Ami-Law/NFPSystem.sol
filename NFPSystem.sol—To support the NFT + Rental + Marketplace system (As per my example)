// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * üîπ NFPSystem.sol
 * ‡∏£‡∏ß‡∏°‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÉ‡∏ô Remix
 *
 * Contracts:
 * - NFPRegistry: ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏ú‡∏•‡∏á‡∏≤‡∏ô/‡πÄ‡∏°‡∏ï‡∏≤‡∏î‡∏≤‡∏ï‡πâ‡∏≤
 * - NFP721: NFT ERC721 (‡∏Å‡∏£‡∏£‡∏°‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå)
 * - NFPRenter: ‡πÉ‡∏´‡πâ‡πÄ‡∏ä‡πà‡∏≤/‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡πà‡∏≤‡∏¢ USDC
 * - NFPMarketplace: ‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏Ç‡∏≤‡∏¢/‡πÄ‡∏ä‡πà‡∏≤/‡∏õ‡∏£‡∏∞‡∏°‡∏π‡∏• ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡πà‡∏≤‡∏¢ USDC ‡πÅ‡∏•‡∏∞‡πÇ‡∏≠‡∏ô NFT
 * - NFPAccessController: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á
 * - NFP1155Chapters: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏ó/‡∏ï‡∏≠‡∏ô‡∏¢‡πà‡∏≠‡∏¢ (ERC1155)
 */

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/common/ERC2981.sol";
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// ---------------------------
/// 1) NFPRegistry
/// ---------------------------
contract NFPRegistry {
    struct Work {
        string metadataURI;
        address creator;
        bool exists;
    }

    mapping(uint256 => Work) public works;
    uint256 public workCounter;

    event WorkRegistered(uint256 workId, address creator, string metadataURI);

    function registerWork(string memory metadataURI) external returns (uint256) {
        workCounter++;
        works[workCounter] = Work(metadataURI, msg.sender, true);
        emit WorkRegistered(workCounter, msg.sender, metadataURI);
        return workCounter;
    }
}

/// ---------------------------
/// 2) NFP721 (ERC721 + ERC2981)
/// ---------------------------
contract NFP721 is ERC721URIStorage, ERC2981, AccessControl {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor() ERC721("NFP721", "NFP") {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
    }

    function mint(address to, string memory tokenURI, address royaltyReceiver, uint96 feeNumerator)
        external
        onlyRole(MINTER_ROLE)
        returns (uint256)
    {
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        _mint(to, newItemId);
        _setTokenURI(newItemId, tokenURI);
        _setTokenRoyalty(newItemId, royaltyReceiver, feeNumerator);
        return newItemId;
    }

    /// required override
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721URIStorage, ERC2981, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}

/// ---------------------------
/// 3) NFPRenter (‡∏°‡∏µ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡πà‡∏≤‡∏¢‡∏Ñ‡πà‡∏≤‡πÄ‡∏ä‡πà‡∏≤‡∏ú‡πà‡∏≤‡∏ô USDC)
/// ---------------------------
contract NFPRenter is AccessControl {
    IERC20 public paymentToken;  // ‡πÄ‡∏ä‡πà‡∏ô USDC
    uint256 public rentPricePerSecond;

    struct RentInfo {
        address renter;
        uint256 expiry;
    }

    mapping(uint256 => RentInfo) public rentals;

    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    event Rented(uint256 tokenId, address renter, uint256 expiry);

    constructor(address _paymentToken, uint256 _rentPricePerSecond) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);

        paymentToken = IERC20(_paymentToken);
        rentPricePerSecond = _rentPricePerSecond;
    }

    function setRentPricePerSecond(uint256 _price) external onlyRole(ADMIN_ROLE) {
        rentPricePerSecond = _price;
    }

    function rent(uint256 tokenId, uint256 duration) external {
        require(duration > 0, "Invalid duration");

        uint256 totalPrice = rentPricePerSecond * duration;

        // ‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤ ‡∏ï‡πâ‡∏≠‡∏á approve usdc ‡∏Å‡πà‡∏≠‡∏ô‡πÅ‡∏•‡πâ‡∏ß contract ‡∏à‡∏∞‡∏î‡∏∂‡∏á‡∏à‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
        require(paymentToken.transferFrom(msg.sender, address(this), totalPrice), "Payment failed");

        rentals[tokenId] = RentInfo(msg.sender, block.timestamp + duration);

        emit Rented(tokenId, msg.sender, block.timestamp + duration);
    }

    function isRenter(uint256 tokenId, address user) public view returns (bool) {
        return rentals[tokenId].renter == user && rentals[tokenId].expiry > block.timestamp;
    }

    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡πâ Admin ‡∏ñ‡∏≠‡∏ô USDC ‡∏≠‡∏≠‡∏Å (‡∏Å‡∏£‡∏ì‡∏µ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ö‡∏¥‡∏Å)
    function withdrawPayments(address to, uint256 amount) external onlyRole(ADMIN_ROLE) {
        require(paymentToken.transfer(to, amount), "Withdraw failed");
    }
}

/// ---------------------------
/// 4) NFPMarketplace (‡∏°‡∏µ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡πà‡∏≤‡∏¢ USDC ‡πÅ‡∏•‡∏∞‡πÇ‡∏≠‡∏ô NFT ‡πÉ‡∏ô purchase)
/// ---------------------------
contract NFPMarketplace is ReentrancyGuard, AccessControl {
    using Counters for Counters.Counter;
    enum ListingType { Sale, Rent, Auction }

    struct Listing {
        address owner;
        uint256 tokenId;
        uint256 price;
        ListingType listingType;
        bool active;
    }

    mapping(uint256 => Listing) public listings;
    Counters.Counter public listingCounter;

    IERC20 public usdcToken;
    NFP721 public nfp721;

    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    event Listed(uint256 listingId, address owner, uint256 tokenId, uint256 price, ListingType listingType);
    event Purchased(uint256 listingId, address buyer);

    constructor(address _usdcToken, address _nfp721) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);

        usdcToken = IERC20(_usdcToken);
        nfp721 = NFP721(_nfp721);
    }

    function setUSDC(address _usdcToken) external onlyRole(ADMIN_ROLE) {
        usdcToken = IERC20(_usdcToken);
    }

    function setNFP721(address _nfp721) external onlyRole(ADMIN_ROLE) {
        nfp721 = NFP721(_nfp721);
    }

    function list(uint256 tokenId, uint256 price, ListingType listingType) external returns (uint256) {
        // ‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ
        require(nfp721.ownerOf(tokenId) == msg.sender, "Not token owner");
        require(price > 0, "Price must be > 0");

        listingCounter.increment();
        uint256 currentId = listingCounter.current();

        listings[currentId] = Listing(msg.sender, tokenId, price, listingType, true);

        emit Listed(currentId, msg.sender, tokenId, price, listingType);
        return currentId;
    }

    function purchase(uint256 listingId) external nonReentrant {
        Listing storage l = listings[listingId];
        require(l.active, "Listing inactive");
        require(l.listingType == ListingType.Sale, "Not sale");

        address owner = nfp721.ownerOf(l.tokenId);
        require(owner == l.owner, "Seller not owner");

        // ‡∏£‡∏±‡∏ö‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô USDC ‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡∏ã‡∏∑‡πâ‡∏≠ (‡∏ï‡πâ‡∏≠‡∏á approve ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏Å)
        require(usdcToken.transferFrom(msg.sender, l.owner, l.price), "Payment failed");

        // ‡πÇ‡∏≠‡∏ô NFT ‡πÑ‡∏õ‡∏ú‡∏π‡πâ‡∏ã‡∏∑‡πâ‡∏≠
        nfp721.safeTransferFrom(owner, msg.sender, l.tokenId);

        l.active = false;
        emit Purchased(listingId, msg.sender);
    }
}

/// ---------------------------
/// 5) NFPAccessController
/// ---------------------------
contract NFPAccessController {
    NFP721 public nfp721;
    NFPRenter public renter;

    constructor(address _nfp721, address _renter) {
        nfp721 = NFP721(_nfp721);
        renter = NFPRenter(_renter);
    }

    function hasAccess(uint256 tokenId, address user) external view returns (bool) {
        if (nfp721.ownerOf(tokenId) == user) return true;
        if (renter.isRenter(tokenId, user)) return true;
        return false;
    }
}

/// ---------------------------
/// 6) NFP1155Chapters
/// ---------------------------
contract NFP1155Chapters is ERC1155, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor(string memory uri) ERC1155(uri) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
    }

    function mint(address to, uint256 id, uint256 amount, bytes memory data) public onlyRole(MINTER_ROLE) {
        _mint(to, id, amount, data);
    }

    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
        public
        onlyRole(MINTER_ROLE)
    {
        _mintBatch(to, ids, amounts, data);
    }

    /// ‚úÖ ‡πÅ‡∏Å‡πâ error supportsInterface
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC1155, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
